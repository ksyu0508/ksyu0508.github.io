---
layout: post
title: 파이썬 내장함수 pow
subtitle: 
categories: [python]
tags: [pow, cpython, modular]
published: False
# github blog template

# 0. 포스트 배너 삽입
# banner:
#   image: {이미지 링크}
#   opacity: 0.5
#   background: "rgba(0, 0, 0, 1)"  # Banner background (Could be a image)

# 1. 링크 넣기
# {% linkpreview "{링크 주소}" %}

# 2. 사진 넣기
# ![]({사진 주소})
# *<center>{사진 설명}</center>*

# 3. 줄 번호 있는 코드
# {% highlight {코드 종류} wl linenos %}
# {% endhighlight %}

# 4. 동영상 넣기
# ![]({유튜브 임베드 링크})
---

파이썬에서 거듭제곱을 계산하기 위한 방법은 여러가지 존재한다. `**` 연산자를 이용하는 방법, `math` 모듈의 `pow()` 메소드, 파이썬 내장함수의 `pow()` 등이 존재한다.
표현 방식의 차이가 있지만, 실제로 성능 상의 차이가 존재할까?
파이썬 내장 모듈 `timeit`을 활용하여 각각의 방법의 장단점을 확인해보고자 한다.

## 적당히 큰 수에서
처음에는 `2^1000` 정도의 숫자로 가볍게 테스트를 진행해보려고 한다. `2^1000`는 컴퓨터로 계산하면 얼마 걸리지 않는 숫자이지만, `10715···69376`로 대략 `10^302` 정도의 크기를 갖는 매우 큰 수 이다.

```PYTHON
>>> print(f"**: {timeit('2 ** 1000', number=10000, globals=globals()):.8f}s")
**: 0.00611310s

>>> print(f"pow: {timeit('pow(2, 1000)', number=10000, globals=globals()):.8f}s")
pow: 0.00680620s

>>> print(f"math.pow: {timeit('math.pow(2, 1000)', number=10000, globals=globals()):.8f}s")
math.pow: 0.00201840s
```

속도로는 `math.pow` >> `**` >= `pow` 임을 확인할 수 있다.

## 매우 큰 수에서
그렇다면 조금 더 키워서 `2^100000`이면 어떻게 될까? `2^100000`는 30103자리의 매우매우 큰 수이다.

```PYTHON
>>> print(f"**: {timeit('2 ** 100000', number=10000, globals=globals()):.8f}s")
**: 1.64582450s

>>> print(f"pow: {timeit('pow(2, 100000)', number=10000, globals=globals()):.8f}s")
pow: 1.65175850s

>>> print(f"math.pow: {timeit('math.pow(2, 100000)', number=10000, globals=globals()):.8f}s")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  ···
  File "<timeit-src>", line 6, in inner
OverflowError: math range error
```

`math.pow`는 우리가 일반적으로 파이썬에서는 접하기 힘든 `OverflowError`가 발생한다. 사실 별 이유는 없고 `math.pow`의 리턴값이 다른 두 방법과는 다르게 `float`을 활용하는데, 내부적으로 `float`자료형을 사용하면서 `2^100000`을 `float`으로 다루기에는 매우 크기 때문인 것으로 예상된다. 실제로 `float(2 ** 100000)`을 실행해본다면

'''PYTHON
>>> float(2 ** 100000)           
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: int too large to convert to float
'''

`int`로는 문제 없는 계산 결과가 `OverflowError`가 발생함을 알 수 있다. 하지만 코딩 테스트 특수한 환경에서 조차 `2 ** 1000` 크기의 숫자는 쉽게 보지 못할 것이므로, 제곱의 속도가 중요하다면, 그냥 `math.pow`를 활용하면 될 것이다.

## 공식 문서 설명

`math` 모듈의 공식 문서를 읽어보면
>math.pow(x, y)
>
>Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.
>
>Unlike the built-in ** operator, math.pow() converts both its arguments to type float. Use ** or the built-in pow() function for computing exact integer powers.

맨 밑 줄을 읽어본다면, `**` 연산자와는 다르게, 두 인자의 값을 float으로 변환한 후 계산을 진행하며, `**`와 그냥 `pow`는 정수로 계산되는 함수라고 나와있다.

파이썬 내장함수의 공식 문서를 읽어보면

> pow(base, exp, mod=None)
>
> Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp.

모듈러 값이 없는 상황에서는, `**` 연산자를 사용하는 것과 동일하다고 나와있다. `cpython`의 내부 구현을 살펴 본다면, `Decimal`객체 안에 정의가 되어 있으며, 정의가 꽤 길기 때문에 다 살펴 볼 수는 없지만, 간단하게 `mod` 인자가 있을 때에는 `_power_modular()`라는 별도의 메서드를 통해서 계산을 진행하며, 그렇지 않은 경우에는 x, y의 특수한 케이스(0, 1, `NaN`, `infinity`)에 대한 if 문 처리를 지나고서 `usual case: inexact result, x**y computed directly as exp(y*log(x))`라고 명시된 부분에서 `**` 연산자와 동일하게 계산을 진행함을 알 수 있다.
`__pow__`의 정의는 [여기서](https://github.com/python/cpython/blob/67bba9dd0f5b9c2d24c2bc6d239c4502040484af/Lib/_pydecimal.py#L2201) 확인할 수 있다.

## + 모듈러
그렇다면 내장 함수 `pow(base, exp, mod=None)`에서 `mod`는 무엇일까? 이름에서 눈치 챌 수 있지만, 파이썬의 제곱 내장 함수 `pow`는 `base`와 `exp`의 제곱근에 대한 모듈러 연산을 바로 진행할 수 있도록 구현해놓았다. 그것도 매우 효율적으로... 코딩테스트에서 매우 큰 수를 다루는 문제의 경우 마지막 결과에 대해서 모듈러 연산을 다루는 경우가 많은데, 내장 함수의 `mod` 인자를 알고 있다면, 내장 함수임으로 언제든지 쓸 수 있기 때문에 코딩테스트에서 매우 큰 도움이 될 것이다.

